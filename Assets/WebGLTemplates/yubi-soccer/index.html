<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Unity Web Player | {{{ PRODUCT_NAME }}}</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
#if SHOW_DIAGNOSTICS
    <link rel="stylesheet" href="<<<TemplateData/diagnostics.css>>>">
    <script src="<<<TemplateData/diagnostics.js>>>"></script>
#endif
  </head>
  <body>
    <div id="unity-container" class="unity-desktop">
      <canvas id="unity-canvas" width={{{ WIDTH }}} height={{{ HEIGHT }}} tabindex="-1"></canvas>
      <div id="unity-loading-bar">
        <div id="unity-logo"></div>
        <div id="unity-progress-bar-empty">
          <div id="unity-progress-bar-full"></div>
        </div>
      </div>
      <div id="unity-warning"> </div>
      <!-- Recognition overlay: UnityからJSONを受け取って表示します -->
      <div id="recognition-panel" class="recognition-hidden" aria-live="polite">
        <div id="recognition-header">Recognition</div>
        <pre id="recognition-content">(no data)</pre>
      </div>
      <div id="unity-footer">
        <div id="unity-logo-title-footer"></div>
        <div id="unity-fullscreen-button"></div>
#if SHOW_DIAGNOSTICS
        <img id="diagnostics-icon" src="TemplateData/webmemd-icon.png">
#endif
        <div id="unity-build-title">{{{ PRODUCT_NAME }}}</div>
      </div>
  </div>
  <!-- 認識結果表示用スクリプト -->
  <script src="TemplateData/recognition_overlay.js"></script>
    <!-- Yubi-Soccer 埋め込み（iframe）: TemplateData/embedded_yubi に Yubi-Soccer の Web ビルドを置いてください -->
    <div id="yubi-container">
      <!-- Responsive square iframe: size based on viewport height (height = 38vh), width set equal to height to keep square -->
      <iframe id="yubi-iframe" src="TemplateData/embedded_yubi/index.html" title="Yubi-Soccer"
        style="height:38vh; width:38vh; max-height:420px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); overflow:hidden;">
      </iframe>
      <button id="yubi-toggle" aria-pressed="false">Yubi</button>
    </div>
    <script>
      // iframe を小さく表示しておき、トグルで開閉する簡易ロジック
      (function(){
        const btn = document.createElement('button');
        // If the #yubi-toggle already present, use it; otherwise use the one from DOM
  const toggle = document.getElementById('yubi-toggle');
        const iframe = document.getElementById('yubi-iframe');
  // hide the old Yubi toggle button — we replace it with a modal-driven flow
  if (toggle) toggle.style.display = 'none';
        function setVisible(visible){
          if(!iframe) return;
          iframe.style.opacity = visible ? '1' : '0.0';
          iframe.style.pointerEvents = visible ? 'auto' : 'none';
          if(toggle) toggle.setAttribute('aria-pressed', visible ? 'true' : 'false');
        }
        // 初期は小さく表示（半透明で操作不可）。ユーザがボタンで展開できます。
        setVisible(false);
        if(toggle){
          toggle.onclick = function(){
            const pressed = toggle.getAttribute('aria-pressed') === 'true';
            setVisible(!pressed);
          };
        }
      })();

  // Debug helper: call from the console to test SendMessage path
      window.__embeddedRelayTest = function(state, confidence){
        state = state || 'RUN';
        confidence = (typeof confidence === 'number') ? confidence : 0.99;
        var p = { type: 'embedded_state', state: state, confidence: confidence };
        if (window.unityInstance && typeof window.unityInstance.SendMessage === 'function'){
          try {
            window.unityInstance.SendMessage('EmbeddedReceiver', 'OnEmbeddedState', JSON.stringify(p));
            console.log && console.log('[EmbeddedRelay] test sent to EmbeddedReceiver', p);
          } catch (e) {
            console.error && console.error('[EmbeddedRelay] test send failed', e);
          }
          } else {
          try { window.__pendingEmbeddedStates.push({ origin: 'console-test', payload: p, ts: Date.now() }); console.warn && console.warn('[EmbeddedRelay] test queued (unityInstance not ready)', p); } catch (e) { }
        }
      };
      
      // --- Camera selection modal (main page) ---
      (function(){
        // Insert modal HTML into the page
        var modal = document.createElement('div');
        modal.id = 'cameraModal';
        modal.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:9999;';
        modal.innerHTML = '\n          <div id="cameraModalPanel" style="background:#111;color:#fff;padding:20px;border-radius:10px;min-width:320px;max-width:90vw;text-align:left">\n            <h3 style="margin:0 0 10px">カメラを選択して開始</h3>\n            <div style="margin-bottom:12px">\n              <select id="cameraSelectMain" style="width:100%;padding:8px;border-radius:6px;background:#000;color:#fff;border:1px solid rgba(255,255,255,0.08)"></select>\n            </div>\n            <div style="display:flex;gap:8px;justify-content:flex-end">\n              <button id="cameraStartMain" style="padding:8px 12px;border-radius:6px;background:#36c;border:none;color:#fff;font-weight:700">開始</button>\n            </div>\n          </div>\n        ';
        document.body.appendChild(modal);

        var cameraSelectMain = document.getElementById('cameraSelectMain');
        var cameraStartMain = document.getElementById('cameraStartMain');
        async function listVideoDevicesEnsuringPermissionMain(){
          try{
            let devices = await navigator.mediaDevices.enumerateDevices();
            let cams = devices.filter(d => d.kind === 'videoinput');
            const hasLabels = cams.some(d => d.label);
            if (!hasLabels) {
              try { const temp = await navigator.mediaDevices.getUserMedia({ video: true }); temp.getTracks().forEach(t=>t.stop()); } catch(e) { }
              devices = await navigator.mediaDevices.enumerateDevices();
              cams = devices.filter(d => d.kind === 'videoinput');
            }
            return cams;
          }catch(e){ return []; }
        }

        async function populateAndShow(){
          const cams = await listVideoDevicesEnsuringPermissionMain();
          cameraSelectMain.innerHTML = '';
          if (!cams || cams.length === 0){
            var opt = document.createElement('option'); opt.value=''; opt.textContent='利用可能なカメラがありません'; cameraSelectMain.appendChild(opt);
          } else {
            for (const c of cams){ var o = document.createElement('option'); o.value = c.deviceId; o.textContent = c.label || ('カメラ ('+c.deviceId.slice(0,6)+')'); cameraSelectMain.appendChild(o); }
          }
          // modal already visible on append
        }

        cameraStartMain.addEventListener('click', function(){
          // DeviceOrientation パーミッション要求（ユーザージェスチャー内で実行）
          if (window.requestOrientationPermission) {
            window.requestOrientationPermission();
          }
          
          var id = cameraSelectMain.value || null;
          // iframe は別 IIFE 内で定義されている可能性があるため、ここで明示的に DOM から取得する
          var iframeEl = document.getElementById('yubi-iframe');
          // make iframe visible and allow interaction
          if (iframeEl){ iframeEl.style.opacity = '1'; iframeEl.style.pointerEvents = 'auto'; }
          try {
            // send start command to embedded iframe
            if (iframeEl && iframeEl.contentWindow) iframeEl.contentWindow.postMessage({ type: 'start_camera', deviceId: id }, '*');
          } catch(e){}
          // hide modal
          modal.style.display = 'none';
        });

        // Populate list and show modal immediately
        populateAndShow();
      })();
    </script>
    <!-- Orientation-aware placement: place the embedded camera square left/right in landscape (bottom anchored) -->
    <script>
      (function(){
        var lastGamma = null, lastBeta = null;
        var lastSide = 'right'; // fallback default

        // DeviceOrientation パーミッション要求（iOS 13+）
        function requestOrientationPermission(){
          if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            // iOS 13+ requires permission
            DeviceOrientationEvent.requestPermission()
              .then(function(response){
                if (response === 'granted') {
                  console.log('[Orientation] Permission granted');
                  attachOrientationListener();
                } else {
                  console.warn('[Orientation] Permission denied');
                }
              })
              .catch(function(e){
                console.error('[Orientation] Permission request failed', e);
              });
          } else {
            // Non-iOS or older iOS: attach listener directly
            attachOrientationListener();
          }
        }
        
        // グローバルに公開（カメラ開始ボタンから呼べるように）
        window.requestOrientationPermission = requestOrientationPermission;

        function attachOrientationListener(){
          window.addEventListener('deviceorientation', function(ev){
            if (typeof ev.gamma === 'number') lastGamma = ev.gamma; // 左右傾き [-90,90]
            if (typeof ev.beta === 'number') lastBeta = ev.beta;   // 前後傾き [-180,180]
          }, { passive: true });
        }

        // 非iOS環境では即座にリスナーを登録
        if (typeof DeviceOrientationEvent === 'undefined' || typeof DeviceOrientationEvent.requestPermission !== 'function') {
          attachOrientationListener();
        }

        function inRangeDeg(a, lo, hi){
          // 角度 a(0..360) が [lo,hi] に入るか
          while (a < 0) a += 360; while (a >= 360) a -= 360;
          if (lo <= hi) return a >= lo && a <= hi;
          return a >= lo || a <= hi; // wrap-around
        }

        function normalizeDeg(a){
          if (typeof a !== 'number' || isNaN(a)) return null;
          var n = a % 360; if (n < 0) n += 360; return n;
        }

        function detectLandscapeSide(){
          var result = null;

          // 優先順位1: DeviceOrientation の gamma（物理的な傾き）- 画面回転ロックに影響されない
          try {
            if (lastGamma != null && lastBeta != null) {
              var betaAbs = Math.abs(lastBeta);
              if (betaAbs < 60) {
                // beta が小さい（通常の持ち方）: gamma 値で判定
                // 横持ち時のgamma値: 右手で持つと正、左手で持つと負
                // 閾値を広げて検出しやすく（±5°）
                if (lastGamma > 5) { result = 'right'; }
                else if (lastGamma < -5) { result = 'left'; }
              } else {
                // beta が大きい（手前に傾けた時）: 判定を逆転
                if (lastGamma > 5) { result = 'left'; }
                else if (lastGamma < -5) { result = 'right'; }
              }
            }
          } catch(e){}

          // 優先順位2: window.orientation（iOS/一部Android）
          if (!result) {
            try {
              var o = (typeof window.orientation === 'number') ? window.orientation : null;
              var oa = normalizeDeg(o);
              if (oa != null) {
                if (inRangeDeg(oa, 60, 120)) { result = 'right'; }
                else if (inRangeDeg(oa, 240, 300)) { result = 'left'; }
              }
            } catch(e){}
          }

          // 優先順位3: Screen Orientation API
          if (!result) {
            try {
              if (screen.orientation) {
                var ang = normalizeDeg(screen.orientation.angle);
                var typ = String(screen.orientation.type || '');
                if (ang != null) {
                  if (inRangeDeg(ang, 60, 120)) { result = 'right'; }
                  else if (inRangeDeg(ang, 240, 300)) { result = 'left'; }
                }
                if (!result) {
                  if (typ.indexOf('landscape-primary') !== -1) { result = 'right'; }
                  else if (typ.indexOf('landscape-secondary') !== -1) { result = 'left'; }
                }
              }
            } catch(e){}
          }

          // 判断不能 → 直前の結果を維持
          if (!result) {
            result = lastSide || 'right';
          }

          return result;
        }

        function applyPlacement(){
          var cont = document.getElementById('yubi-container');
          if (!cont) return;
          var side = detectLandscapeSide();
          cont.style.position = 'fixed';
          cont.style.bottom = '12px';
          cont.style.top = 'auto';
          cont.style.zIndex = '1000';
          cont.style.width = 'auto'; // CSSの固定幅を上書き
          cont.style.transition = 'left .3s ease, right .3s ease, bottom .2s ease';
          // 常に側面配置（portrait時も gamma で判定）
          if (side === 'left') {
            cont.style.left = '12px';
            cont.style.right = 'auto';
          } else {
            // right or fallback
            cont.style.right = '12px';
            cont.style.left = 'auto';
          }
          if (side) lastSide = side;
          
          // デバッグ表示を更新
          updateDebugOverlay(side);
        }
        
        // デバッグオーバーレイ表示
        var debugOverlay = null;
        function updateDebugOverlay(side){
          if (!debugOverlay) {
            debugOverlay = document.createElement('div');
            debugOverlay.id = 'orientation-debug';
            debugOverlay.style.cssText = 'position:fixed;top:10px;left:10px;background:rgba(0,255,0,0.8);color:#000;padding:10px;border-radius:5px;font-family:monospace;font-size:12px;z-index:10000;line-height:1.4;';
            document.body.appendChild(debugOverlay);
          }
          
          var betaAbs = Math.abs(lastBeta || 0);
          var mode = betaAbs < 60 ? '通常' : '逆転';
          
          debugOverlay.innerHTML = 
            'gamma: ' + (lastGamma != null ? lastGamma.toFixed(1) : 'null') + '°<br>' +
            'beta: ' + (lastBeta != null ? lastBeta.toFixed(1) : 'null') + '°<br>' +
            '|beta|: ' + betaAbs.toFixed(1) + '°<br>' +
            'モード: ' + mode + '<br>' +
            '判定: ' + side + '<br>' +
            'lastSide: ' + lastSide;
        }

        // 初期適用 & 変化に追従
        try { applyPlacement(); } catch(e){}
        window.addEventListener('resize', applyPlacement);
        window.addEventListener('orientationchange', applyPlacement);
        if (screen.orientation && screen.orientation.addEventListener) {
          screen.orientation.addEventListener('change', applyPlacement);
        }
        document.addEventListener('visibilitychange', applyPlacement);
        // DeviceOrientation の変化を定期的にチェック（画面回転ロック対応）
        setInterval(applyPlacement, 200);
      })();
    </script>
  <script>
      var canvas = document.querySelector("#unity-canvas");

      // Shows a temporary message banner/ribbon for a few seconds, or
      // a permanent error message on top of the canvas if type=='error'.
      // If type=='warning', a yellow highlight color is used.
      // Modify or remove this function to customize the visually presented
      // way that non-critical warnings and error messages are presented to the
      // user.
      function unityShowBanner(msg, type) {
        var warningBanner = document.querySelector("#unity-warning");
        function updateBannerVisibility() {
          warningBanner.style.display = warningBanner.children.length ? 'block' : 'none';
        }
        var div = document.createElement('div');
        div.innerHTML = msg;
        warningBanner.appendChild(div);
        if (type == 'error') div.style = 'background: red; padding: 10px;';
        else {
          if (type == 'warning') div.style = 'background: yellow; padding: 10px;';
          setTimeout(function() {
            warningBanner.removeChild(div);
            updateBannerVisibility();
          }, 5000);
        }
        updateBannerVisibility();
      }

      var buildUrl = "Build";
      var loaderUrl = buildUrl + "/{{{ LOADER_FILENAME }}}";
      var config = {
        arguments: [],
        dataUrl: buildUrl + "/{{{ DATA_FILENAME }}}",
        frameworkUrl: buildUrl + "/{{{ FRAMEWORK_FILENAME }}}",
#if USE_THREADS
        workerUrl: buildUrl + "/{{{ WORKER_FILENAME }}}",
#endif
#if USE_WASM
        codeUrl: buildUrl + "/{{{ CODE_FILENAME }}}",
#endif
#if SYMBOLS_FILENAME
        symbolsUrl: buildUrl + "/{{{ SYMBOLS_FILENAME }}}",
#endif
        streamingAssetsUrl: "StreamingAssets",
        companyName: {{{ JSON.stringify(COMPANY_NAME) }}},
        productName: {{{ JSON.stringify(PRODUCT_NAME) }}},
        productVersion: {{{ JSON.stringify(PRODUCT_VERSION) }}},
        showBanner: unityShowBanner,
      };

      // By default, Unity keeps WebGL canvas render target size matched with
      // the DOM size of the canvas element (scaled by window.devicePixelRatio)
      // Set this to false if you want to decouple this synchronization from
      // happening inside the engine, and you would instead like to size up
      // the canvas DOM size and WebGL render target sizes yourself.
      // config.matchWebGLToCanvasSize = false;

      // If you would like all file writes inside Unity Application.persistentDataPath
      // directory to automatically persist so that the contents are remembered when
      // the user revisits the site the next time, uncomment the following line:
      // config.autoSyncPersistentDataPath = true;
      // This autosyncing is currently not the default behavior to avoid regressing
      // existing user projects that might rely on the earlier manual
      // JS_FileSystem_Sync() behavior, but in future Unity version, this will be
      // expected to change.

      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        // Mobile device style: fill the whole browser client area with the game canvas:

        var meta = document.createElement('meta');
        meta.name = 'viewport';
        meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
        document.getElementsByTagName('head')[0].appendChild(meta);
        document.querySelector("#unity-container").className = "unity-mobile";
        canvas.className = "unity-mobile";

        // To lower canvas resolution on mobile devices to gain some
        // performance, uncomment the following line:
        // config.devicePixelRatio = 1;

#if SHOW_DIAGNOSTICS
        // position the diagnostics icon in the corner on the canvas
        let diagnostics_icon = document.getElementById("diagnostics-icon");
        diagnostics_icon.style.position = "fixed";
        diagnostics_icon.style.bottom = "10px";
        diagnostics_icon.style.right = "0px";
        canvas.after(diagnostics_icon);
#endif

      } else {
        // Desktop style: Render the game canvas in a window that can be maximized to fullscreen:
        canvas.style.width = "{{{ WIDTH }}}px";
        canvas.style.height = "{{{ HEIGHT }}}px";
      }

#if BACKGROUND_FILENAME
      canvas.style.background = "url('" + buildUrl + "/{{{ BACKGROUND_FILENAME.replace(/'/g, '%27') }}}') center / cover";
#endif
      document.querySelector("#unity-loading-bar").style.display = "block";

      var script = document.createElement("script");
      script.src = loaderUrl;

      // Coordination flags: we only start Unity when both the loader script
      // is loaded and the embedded iframe has signalled that its camera
      // / tracker is ready. This prevents Unity from loading before the
      // camera is active.
      window.__cameraReady = window.__cameraReady || false;
      window.__unityScriptLoaded = window.__unityScriptLoaded || false;
      window.__unityStarted = window.__unityStarted || false;

      function startUnityIfReady() {
        if (window.__unityStarted) return;
        if (!window.__unityScriptLoaded) return;
        if (!window.__cameraReady) return;
        window.__unityStarted = true;
        createUnityInstance(canvas, config, (progress) => {
          document.querySelector("#unity-progress-bar-full").style.width = 100 * progress + "%";
        }).then((unityInstance) => {
          document.querySelector("#unity-loading-bar").style.display = "none";
          // expose unityInstance globally so other scripts can SendMessage to Unity
          window.unityInstance = unityInstance;

                // === ここから追加：Unityの標準出力/標準エラーをブラウザコンソールへ束ねる ===
                try {
                  // Unityのバージョン差を吸収するため、Moduleを確実に持たせる
                  unityInstance.Module = unityInstance.Module || {};
                  unityInstance.Module.print = (text) => {
                    try { console.log('[Unity]', text); } catch (e) {}
                  };
                  unityInstance.Module.printErr = (text) => {
                    try { console.error('[Unity]', text); } catch (e) {}
                  };
                } catch (e) {
                  console.warn('[Unity] failed to hook Module.print/printErr', e);
                }
                // === 追加ここまで ===

#if SHOW_DIAGNOSTICS
                document.getElementById("diagnostics-icon").onclick = () => {
                  unityDiagnostics.openDiagnosticsDiv(unityInstance.GetMetricsInfo);
                };
#endif
                document.querySelector("#unity-fullscreen-button").onclick = () => {
                  unityInstance.SetFullscreen(1);
                };

#if DEVELOPMENT_PLAYER
                // Unloading web content from DOM so that browser GC can run can be tricky to get right.
                // This code snippet shows how to correctly implement a Unity content Unload mechanism to a web page.

                // Unloading Unity content enables a web page to reclaim the memory used by Unity, e.g. for
                // the purpose of later loading another Unity content instance on the _same_ web page.

                // When using this functionality, take caution to carefully make sure to clear all JavaScript code,
                // DOM element and event handler references to the old content you may have retained, or
                // otherwise the browser's garbage collector will be unable to reclaim the old page.

                // N.b. Unity content does _not_ need to be manually unloaded when the user is navigating away from
                // the current page to another web page. The browser will take care to clear memory of old visited
                // pages automatically. This functionality is only needed if you want to switch between loading
                // multiple Unity builds on a single web page.
                var quit = document.createElement("button");
                quit.style = "margin-left: 5px; background-color: lightgray; border: none; padding: 5px; cursor: pointer";
                quit.innerHTML = "Unload";
                document.querySelector("#unity-build-title").appendChild(quit);
                quit.onclick = () => {
                  // Quit Unity application execution
                  unityInstance.Quit().then(() => {
                    // Remove DOM elements from the page so GC can run
                    document.querySelector("#unity-container").remove();
                    canvas = null;
                    // Remover script elements from the page so GC can run
                    script.remove();
                    script = null;
                  });
                };
#endif
              }).catch((message) => {
                alert(message);
              });
      };

      script.onload = () => {
        window.__unityScriptLoaded = true;
        console.log && console.log('[EmbeddedRelay] unity loader script loaded, waiting for camera ready...');
        startUnityIfReady();
      };

      // Receive messages from embedded iframe (Yubi-Soccer) and forward to Unity or overlay
      (function(){
        // pending queue if unityInstance not ready yet
        window.__pendingEmbeddedStates = window.__pendingEmbeddedStates || [];
        var __didLogUnityReady = false;
        function tryFlushPending() {
          if (!window.unityInstance || typeof window.unityInstance.SendMessage !== 'function') return;
          try {
            if (!__didLogUnityReady && window.__pendingEmbeddedStates && window.__pendingEmbeddedStates.length) {
              console.log && console.log('[EmbeddedRelay] unityInstance ready, flushing pending (collapsing duplicates)', window.__pendingEmbeddedStates.length);
              __didLogUnityReady = true;
            }

            // Collapse pending entries by origin, keep only the last entry per origin.
            var lastByOrigin = {};
            while (window.__pendingEmbeddedStates && window.__pendingEmbeddedStates.length) {
              try {
                var item = window.__pendingEmbeddedStates.shift();
                if (!item) continue;
                var o = item.origin || 'unknown';
                lastByOrigin[o] = item; // overwrite; we keep the last one
              } catch (e) { /* ignore malformed entries */ }
            }

            // Send only the last entry per origin (apply the same send-throttle logic)
            for (var o in lastByOrigin) {
              if (!lastByOrigin.hasOwnProperty(o)) continue;
              var it = lastByOrigin[o];
              var p = it.payload || it; // support older shape
              var nowTs = Date.now();
              var lastSent = __lastSentByOrigin[o];
              var lastTs = __lastSentTsByOrigin[o] || 0;
              // Only forward pending states when the state changed since the last forwarded state
              var shouldSend = (lastSent !== p.state);
              if (!shouldSend) {
                // suppressed (no state change) — don't spam console
                continue;
              }
              var s = JSON.stringify(p);
              var pendingSent = false;
              try { window.unityInstance.SendMessage('EmbeddedReceiver', 'OnEmbeddedState', s); pendingSent = true; } catch (e) { console.warn('[EmbeddedRelay] pending->EmbeddedReceiver failed', e); }
              if (pendingSent) {
                console.log && console.log('[EmbeddedRelay] Sent pending for origin', o, p);
                __lastSentByOrigin[o] = p.state;
                __lastSentTsByOrigin[o] = nowTs;
              }
            }
          } catch (e) { console.warn('[EmbeddedRelay] flush error', e); }
        }

        // periodically try to flush pending states if Unity wasn't ready yet
        setInterval(tryFlushPending, 500);

  // Keep last logged state per origin to reduce noise
  var __lastStateByOrigin = {};
  // Track last state we actually forwarded to Unity and when, per origin.
  // This lets us suppress repeated 'NONE' / low-confidence messages while
  // still ensuring occasional heartbeat updates and any real changes
  // are forwarded immediately.
  var __lastSentByOrigin = {};
  var __lastSentTsByOrigin = {};
  var __SEND_MIN_INTERVAL_MS = 500; // at most one identical-state send per origin per 500ms

        window.addEventListener('message', function(ev){
          var data = ev.data;
          try { if (typeof data === 'string') data = JSON.parse(data); } catch(e) { /* keep original */ }
          // Handle camera readiness messages from embedded iframe
          if (data && data.type === 'camera') {
            try {
              var origin = ev.origin || 'unknown';
              if (data.status === 'ready') {
                window.__cameraReady = true;
                console.log && console.log('[EmbeddedRelay] camera ready from', origin);
                // Try starting Unity if loader already loaded
                try { startUnityIfReady(); } catch(e){}
              }
            } catch(e) {}
            return;
          }
          if (!data || data.type !== 'state') return;
          var origin = ev.origin || 'unknown';

          try {
            var prevState = __lastStateByOrigin[origin];
            if (prevState !== data.state) {
              console.log && console.log('[EmbeddedRelay] message received from', origin, data);
            }
            __lastStateByOrigin[origin] = data.state;
          } catch (e){}

          var payload = { type: 'embedded_state', state: data.state, confidence: data.confidence };

          // If Unity instance available, try a single JSON SendMessage to the known receiver.
          if (window.unityInstance && typeof window.unityInstance.SendMessage === 'function'){
            var nowTs = Date.now();
            var lastSent = __lastSentByOrigin[origin];
            var shouldSend = (lastSent !== payload.state);

            if (shouldSend) {
              var s = JSON.stringify(payload);
              try {
                window.unityInstance.SendMessage('EmbeddedReceiver', 'OnEmbeddedState', s);
                console.log && console.log('[EmbeddedRelay] Sent to EmbeddedReceiver', payload);
                __lastSentByOrigin[origin] = payload.state;
                __lastSentTsByOrigin[origin] = nowTs;
              } catch (e) {
                try { window.__pendingEmbeddedStates.push({ origin: origin, payload: payload, ts: Date.now() }); } catch (ee) { /* ignore */ }
                console.warn && console.warn('[EmbeddedRelay] SendMessage failed, queued', e);
              }
            } else {
              try { window.__pendingEmbeddedStates.push({ origin: origin, payload: payload, ts: Date.now() }); } catch (e) { /* ignore */ }
            }
            if (window.updateRecognition) window.updateRecognition(payload);
            return;
          }

          // Unity not ready — queue and update overlay
          try {
            window.__pendingEmbeddedStates.push({ origin: origin, payload: payload, ts: Date.now() });
          } catch (e){}
          if (window.updateRecognition) window.updateRecognition(payload);
        }, false);
      })();

      document.body.appendChild(script);

    </script>
  </body>
</html>
